<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Herramientas Computacionales para Data Science</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jonathan Acosta - Danilo Alvares - Luis Castro" />
    <script src="libs/header-attrs-2.8/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">



class: middle, bottom
background-image: url(media/logo.png)
background-position: 50% 10%
background-size: 60%

&lt;style type="text/css"&gt;

.remark-slide-content {
    font-size: 23px;
}

.remark-code{ 
font-size: 23px;
}

p{
text-align: justify;
}

.azul{
color:#23395b ;
}

.grone{
color: black;
}

code.bold{
font-weight: bold;
}

.blanco{
color: white;
}

.aux{
color: #f1e2ff
}


code.blanco{
color: white;
font-weight: bold;
}

.small{ font-size: 23px }

.large{ font-size: 110% }

.larger{ font-size: 150% }

tr:nth-child(odd) {background-color: #f5f5f5;}

tr.high {
  background-color: #e64964;
  color: white;
}

td.high {
  background-color: #e64964;
  color: white;
}
th.high {
  background-color: #e64964;
  color: white;
}

td {
  text-align: center;
}


&lt;/style&gt; 

.center[
&lt;h2 style="color:#000000"&gt; Clase 2: Tipos de Aprendizaje y Etapas del modelamiento en Machine Learning &lt;/h2&gt;


&lt;div style="color:#43434c; font-size: 40px;"&gt;&lt;b&gt;Herramientas Computacionales para Data Science&lt;/b&gt;&lt;/div&gt;

&lt;div style="color:#43434c; font-size: 45px;"&gt;Jonathan Acosta - Danilo Alvares - Luis Castro &lt;/div&gt;
]
&lt;/br&gt;



---
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;

### Recordemos... ¿Qué es el Machine Learning?

El Machine Learning es la capacidad de las computadoras de aprender sin ser explícitamente programadas para un determinado propósito o tarea. Esta capacidad de aprendizaje se basa en los algoritmos (conjunto de instrucciones o reglas definidas, no ambiguas, ordenadas y finitas). 

En Machine Learning, un algoritmo se aplica a los datos, lo que da origen a lo que llamamos _modelo_.  Lo que buscan los modelos es generalizar lo suficientemente bien como para predecir o clasificar casos nuevos de forma precisa. 


---

class: middle, inverse

# Tipos de Aprendizaje 

---

### Clasificación de imágenes 

Imagine que tenemos un conjunto de imágenes de gatos y perros y cada imagen tiene su etiqueta respectiva. La idea es que al entrenar el modelo (que se obtiene de la aplicación de un algoritmo en los datos de entrenamiento), si ingresa una nueva imagen, se pueda predecir con alta precisión si la imagen corresponde a un gato o a un perro.

&lt;center&gt;
&lt;img src="media/catdogs.gif" width="700height="320"&gt;
&lt;/center&gt;

---
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
 
### Los algoritmos aprenden de los datos

Sabemos que los algoritmos se aplican a los datos y un detalle muy importante es que dependiendo del _approach_ del problema, tendremos ciertas diferencias en los datos y su estructura que harán que el algoritmo tenga que aprender de una forma determinada. 

Profundizaremos en:

- Algoritmos de Aprendizaje Supervisado
- Algoritmos de Aprendizaje No Supervisado

---

### Clasificación de imágenes

En el ejemplo anterior, teníamos un conjunto de imágenes y cada imagen tenía su etiqueta: si era gato o perro. El conjunto de datos se encuentra estructurado de la siguiente forma:

&lt;center&gt;
&lt;img src="media/resp1.png" width="450" height="450"&gt;
&lt;/center&gt;

---

### Gatos y Perros etiquetados: Aplicación de Algoritmos Supervisados

En los algoritmos de Aprendizaje Supervisado la data es de la forma `\(\left \{x_i, y_i\right \}_{i=1}^{n}\)` donde `\(X=\left \{x_i\right \}_{i=1}^{n}\)` se denominan _inputs_ o _variables de entrada_ e `\(y_i\)` es el _output_ o _variable de salida_. El modelo representa la _función de mapeo_ `\(f(X)\)` de los inputs a los outputs:

&lt;center&gt;
&lt;img src="media/box.png" width="160" height="190"&gt;
&lt;/center&gt;

Dependiendo de la naturaleza de la variable respuesta `\(Y\)`, el modelo es de clasificación (si `\(Y\)` es categórica) o de regresión (si `\(Y\)` es numérica). Es importante reconocer la naturaleza de la variable respuesta pues a partir de esta, descartamos los modelos que no serían adecuados para el caso de estudio.

---

### ¿Qué hubiera pasado si hubiéramos tenido las imágenes de perros y gatos &lt;u&gt;no etiquetadas&lt;/u&gt;?

&lt;img src="media/cluster.png" width="550" height="400",  align="right"&gt;
&lt;br&gt;
&lt;br&gt;
El enfoque hubiera sido distinto, ya que no existiría la componente `\(Y\)` (output) explícita. En dicho caso, hablamos de un caso de Aprendizaje No Supervisado, y lo que se busca es determinar _grupos_ o _semejanzas_ en las imágenes, de modo que utilizando los features adecuados, en un grupo queden la mayoría de las imágenes de gatos y en otro grupo las imágenes de perros (grupos homogéneos en sí mismos y heterogéneos entre ellos). 

Ejemplo de Algoritmo No Supervisado: _Clustering._

---

### Mismo problema, distinto enfoque

&lt;center&gt;
&lt;img src="media/supervised3.png" width="660" height="530"&gt;
&lt;/center&gt;

---

class: middle, inverse

# Conceptos de Modelamiento en Machine Learning


---

### Etapas de una solución analítica en Machine Learning

Llegar a una solución analítica es un proceso que parte desde comprender el problema, estructurar y recopilar la data hasta controlar, monitorear y utilizar los resultados de la solución. 

&lt;center&gt;
&lt;img src="media/etapa.png" width="700" height="190"&gt;
&lt;/center&gt;


Ya aprendimos que dependiendo del tipo de enfoque (Supervisado o No Supervisado) los algoritmos aprenden de forma diferente y por lo tanto, son diferentes. También sabemos que dependiendo del tipo de variable respuesta (categórica o numérica) debemos descartar ciertos modelos (por ejemplo, si `\(Y\)` es categórica, no tiene sentido utilizar una regresión lineal). Otra parte fundamental de un modelo es la etapa de entrenamiento y posteriormente, la etapa de prueba, ¿qué datos utilizar? ¿de qué manera evaluar al modelo? 

---

### Datos de Entrenamiento y Prueba, ¿qué son?

#### Datos de Entrenamiento

Corresponde al conjunto de datos utilizado para ajustar el modelo, también puede ser utilizado para proporcionar una evaluación imparcial de un ajuste del modelo en el conjunto de datos de entrenamiento mientras se ajustan los hiperparámetros del modelo. 

#### Datos de Prueba

Corresponde al conjunto de datos utilizado para proporcionar una evaluación del ajuste final del modelo entrenado por los datos de entrenamiento.

Notar que estos conjuntos de datos (Entrenamiento y Prueba) son disjuntos. La idea de los Datos de Prueba es exponer al modelo a situaciones (datos) nuevas y evaluar su rendimiento.

Usualmente el conjunto de datos de Entrenamiento es más grande que el de Prueba y se obtienen de forma aleatoria.


---

### Split simple

Un Split simple consiste en una partición aleatoria definiendo las proporciones del conjunto de Entrenamiento y Prueba.

#### En R: Split 70% - 30%


```r
ind_train &lt;- sample(1:nrow(data), size = 0.7*nrow(data), replace = FALSE)

library(dplyr)

iris_train &lt;- data %&gt;% slice(ind_train)
iris_test &lt;- data %&gt;%  slice(-ind_train)
```

#### En Python: Split 70% - 30%


```r
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
```

---

#### Falencias del Modelo derivadas por baja calidad o cantidad de los datos de Entrenamiento

##### Underfitting (subajuste - Alto sesgo y baja varianza)

Si nuestros datos de entrenamiento son muy pocos, nuestro modelo no será capaz de generalizar el conocimiento y estará incurriendo en un ajuste deficiente.

##### Overfitting (sobreajuste - Alta varianza y bajo sesgo)

Al entrenar demasiado o entrenar con datos “raros”, el modelo se ajusta a características muy específicas de los datos de entrenamiento, lo que puede provocar que los datos nuevos queden muy mal clasificados ya que el modelo se aprendió demasiado bien los datos de entrenamiento.

##### Sesgo estereotipado

Un modelo es tan bueno como sus datos lo sean. Han existido diversos casos donde modelos de Machine Learning entregan resultados sexistas o racistas. Por ejemplo, entrenar un modelo basado en imágenes de publicidad de productos de cocina y finalmente llegar a asociar al sexo femenino con estos productos, pues, en las imágenes del conjunto de datos de entrenamiento aparecían solo mujeres usando artículos de cocina. 
&lt;a href="https://arxiv.org/pdf/1707.09457.pdf"&gt;Leer caso aquí.&lt;/a&gt;

---
### Underfitting &amp; Overfitting

&lt;center&gt;
&lt;img src="media/under.png" width="550" height="450"&gt;
&lt;/center&gt;

---

#### Técnicas para tratar falencias del Modelo

##### Underfitting

- Incrementar la complejidad del modelo
- Aumentar el número de covariables
- Eliminar el ruido de los datos
- Aumentar la etapa de Entrenamiento

##### Overfitting

- Reducir la complejidad del modelo
- Utilizar métodos de regularización (Ridge o Lasso)
- Disminuir la etapa de Entrenamiento
- Usar dropout de redes neuronales 


##### Sesgo estereotipado

- Recolectar mejores datos: Más variados y de calidad

---
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;

### Cross Validation

La validación cruzada (CV) es una técnica muy útil para evaluar la efectividad del modelo, particularmente en los casos en que se necesita mitigar el sobreajuste.

Consiste en una técnica para obtener una estimación más confiable del rendimiento del modelo utilizando solo sus datos de entrenamiento. 

También es útil para determinar los hiperparámetros del modelo, en el sentido de obtener un error de prueba más bajo.

---

### K - Fold Cross Validation

Consiste en dividir los datos en `\(k\)` subconjuntos de igual tamaño y repetir el procedimiento `\(k\)` veces de modo que cada vez, uno de los `\(k\)` subconjuntos sea el conjunto de prueba y los otros `\(k-1\)` subconjuntos forman el conjunto de entrenamiento.

&lt;img src="media/kfoldv_2.png" width="550" height="250" ,  align="right" &gt;

Pasos:
- Entrenar modelo con el grupo `\((1,2,…,i-1,i+1,…,k)\)`
- Testear con el grupo `\(i\)`
- Guardar métricas de testeo en el grupo `\(i\)`
- Repetir para todos los posibles `\(i=(1,2,…,k)\)` 

---

class: middle, inverse

### Ejemplo

Con la librería caret podemos realizar K - Fold Cross Validation, en este ejemplo, en un modelo de regresión lineal:


```r
library(caret)

train.control_cv &lt;- trainControl(method = "cv", number = 5) #N° de folds

#Se especifica el modelo
model_cv &lt;- train(speed ~., data = cars, method = "lm", 
               trControl = train.control_cv) 

model_cv$results #Resultados resumidos 
```

```
##   intercept     RMSE  Rsquared      MAE    RMSESD RsquaredSD     MAESD
## 1      TRUE 3.170354 0.6741261 2.580769 0.6247549  0.1445849 0.4960941
```

---

class: middle, inverse


```r
model_cv$resample #Resultados de cada iteración
```

```
##       RMSE  Rsquared      MAE Resample
## 1 3.289556 0.7559101 2.842284    Fold1
## 2 4.107445 0.5607650 3.173468    Fold2
## 3 2.636883 0.7711829 2.112215    Fold3
## 4 2.557046 0.8034293 2.019941    Fold4
## 5 3.260841 0.4793431 2.755937    Fold5
```

---

### Métricas de cada iteración en Cross Validation

- RMSE: Raíz del error cuadrático medio. Se calcula, para cada iteración:

`$$RMSE_{i}= \sqrt{\frac{\sum_{l=1}^{n_{i}}{(y_{l}- \hat{y}_{l})^{2}}}{n_{i}}}$$`

Donde `\(y_{l}\)` es la observación, `\(\hat{y}_{l}\)` es el valor ajustado por el modelo y `\(n_{i}\)` corresponde al tamaño del `\(j\)` ésimo pliegue.

- MAE: Error absoluto medio. Se calcula, para cada iteración:

`$$MAE_{i}= \frac{\sum_{l=1}^{n_{i}}{|y_{l}- \hat{y}_{l}|}}{n_{i}}$$`
Estas métricas sirven para comparar modelos.
---

#### K - fold Cross Validation
También se puede aplicar el método Repeated K - fold Cross Validation, donde el proceso de hacer split en k pliegues puede iterarse un determinado número de veces:


```r
train.control_rcv &lt;- trainControl(method = "repeatedcv", 
                              number = 5, repeats = 3)

model_rcv &lt;- train(speed ~., data = cars, method = "lm", 
               trControl = train.control_rcv) 

model_rcv$results 
```

```
##   intercept    RMSE  Rsquared      MAE    RMSESD RsquaredSD     MAESD
## 1      TRUE 3.19366 0.6771095 2.599878 0.5729308  0.1113844 0.4372348
```

---

### Otras variaciones de Cross Validation


#### Leave one out Cross Validation (LOOCV)

En cada iteración se utiliza una sola observación para el conjunto de datos de prueba, dejando al resto como set de entrenamiento, es decir, el modelo se ajusta utilizando `\(n – 1\)` observaciones de entrenamiento.


```r
train.control_lpocv &lt;- trainControl(method = "LOOCV")

model_lpocv &lt;- train(speed ~., data = cars, method = "lm", 
               trControl = train.control_lpocv) 

model_lpocv$results 
```

```
##   intercept     RMSE  Rsquared      MAE
## 1      TRUE 3.244277 0.6169238 2.633568
```


---

#### Leave Group Out Cross Validation (LGOCV)

En este caso, se entrena con un porcentaje de los datos y se prueba con el porcentaje restante, en cada iteración.


```r
train.control_lgocv &lt;- trainControl(method = "LGOCV", number = 10, p=.9)

model_lgocv &lt;- train(speed ~., data = cars, method = "lm", 
               trControl = train.control_lgocv) 

model_lgocv$results 
```

```
##   intercept     RMSE  Rsquared      MAE    RMSESD RsquaredSD    MAESD
## 1      TRUE 2.551328 0.7529651 2.156492 0.7519724  0.2689632 0.777509
```


---
class: middle, inverse

# ¡Gracias!

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
